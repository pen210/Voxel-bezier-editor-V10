<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voxel Bezier Editor — v10 (Arc mode + precise SVG + PNG)</title>
<style>
:root{
  --bg:#071028; --panel:#071426; --accent:#06b6d4; --muted:#94a3b8; --white:#e6eef6; --danger:#ff7b7b;
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;background:linear-gradient(180deg,#071028 0%, #02101a 100%);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;color:var(--white)}
#app{display:flex;height:100vh;gap:10px;padding:10px}
.canvas-wrap{flex:1;position:relative;border-radius:8px;overflow:hidden;background:linear-gradient(180deg,#052033 0%, #071a2a 100%)}
canvas{display:block;width:100%;height:100%;background:transparent;cursor:crosshair}
.toolbar{position:absolute;left:12px;top:12px;background:rgba(6,8,12,0.6);padding:8px;border-radius:8px;backdrop-filter:blur(6px);z-index:120;display:flex;gap:8px;align-items:center;width:calc(100% - 24px)}
.panel{width:420px;max-width:42%;background:rgba(2,6,23,0.96);padding:14px;border-radius:10px;color:var(--muted);box-shadow:0 8px 40px rgba(0,0,0,0.6);overflow:auto}
.row{display:flex;gap:8px;align-items:center;margin:6px 0}
label{min-width:140px;color:var(--muted);font-size:13px}
input[type="number"],select,textarea,input[type="color"],input[type="range"]{background:#071426;border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:6px;border-radius:6px;flex:1}
button{background:var(--accent);border:none;padding:8px 10px;border-radius:8px;color:#022;cursor:pointer}
.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--white)}
.small{font-size:12px;padding:4px 6px}
.point-list{max-height:220px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:6px}
.point-item{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:6px}
.hotkeys{position:absolute;right:16px;top:68px;background:rgba(2,6,23,0.75);padding:10px;border-radius:8px;font-size:12px;color:var(--muted);z-index:110;line-height:1.25}
.footer-tip{position:absolute;right:12px;bottom:12px;color:var(--muted);font-size:13px;z-index:50}
.color-preview{width:20px;height:20px;border-radius:4px;border:1px solid rgba(255,255,255,0.06)}
.stats{background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;color:var(--white);margin-top:8px}
kbd{background:#0b1220;border-radius:4px;padding:2px 6px;border:1px solid rgba(255,255,255,0.03);font-family:monospace}
.footer-small{font-size:12px;color:var(--muted);margin-top:6px}
a.example-link{color:var(--accent);cursor:pointer;text-decoration:underline}
</style>
</head>
<body>
<div id="app">
  <div class="canvas-wrap">
    <div class="toolbar">
      <div style="display:flex;gap:8px;align-items:center;margin-right:6px">
        <button id="fitBtn" class="small ghost">Fit</button>
        <button id="exportPNG" class="small">Export PNG</button>
        <button id="exportSVG" class="small ghost">Export SVG</button>
        <button id="copyArray" class="small ghost">Copy 2D</button>
        <div style="margin-left:8px;color:var(--muted)">Mode:</div>
        <select id="modeSelect" style="margin-left:4px">
          <option value="voxels">Voxels</option>
          <option value="curve">Curve Preview</option>
          <option value="arc">Arc mode (3 pts)</option>
        </select>
      </div>

      <!-- center buttons -->
      <div style="display:flex;gap:8px;align-items:center;margin:0 auto" id="centerActions">
        <button id="undoTop" class="small ghost">Undo</button>
        <button id="redoTop" class="small ghost">Redo</button>
        <button id="copySVGTop" class="small ghost">Copy SVG</button>
        <button id="pasteSVGTop" class="small ghost">Paste SVG</button>
        <button id="deleteTop" class="small ghost">Delete</button>
      </div>
    </div>

    <canvas id="canvas" tabindex="0"></canvas>

    <div class="hotkeys" id="hotkeysBox"></div>
    <div class="footer-tip" id="footerTip">Shift+LMB add • LMB drag • RMB pan • Wheel zoom</div>
  </div>

  <div class="panel" id="panel">
    <h2 id="uiTitle">Voxel Bezier Editor v10</h2>

    <div class="row"><label for="langSelect">Language</label>
      <select id="langSelect">
        <option value="uk">Українська</option>
        <option value="en">English</option>
        <option value="ru">Русский</option>
      </select>
    </div>

    <h3>Viewport & Appearance</h3>
    <div class="row"><label>Background</label><input id="bgColor" type="color" value="#071028"><div class="color-preview" id="bgPreview" style="background:#071028"></div></div>
    <div class="row"><label>Grid cell (px)</label><input id="cellSize" type="number" value="12" min="1"></div>
    <div class="row"><label>Thickness (cells)</label>
      <input id="thickRange" type="range" min="0.1" max="40" step="0.1" value="1" style="width:160px;"><input id="thickVal" type="number" min="0.1" step="0.1" max="200" value="1" style="width:80px"></div>
    <div class="row"><label>Sampling quality</label>
      <select id="samplingQuality"><option value="auto">Auto</option><option value="low">Low</option><option value="medium" selected>Medium</option><option value="high">High</option></select></div>
    <div class="row"><label>Fill gaps (Bresenham)</label><input id="fillGaps" type="checkbox" checked></div>
    <div class="row"><label>Vertical stabilize</label><input id="verticalStabilize" type="checkbox"></div>

    <h3>Symmetry</h3>
    <div class="row"><label>Mirror mode</label>
      <select id="mirrorMode"><option value="none">Disabled</option><option value="vertical">Vertical (X)</option><option value="horizontal">Horizontal (Y)</option><option value="point">From selected point</option></select></div>
    <div class="row"><label>Live mirror</label><input id="liveMirror" type="checkbox" checked></div>
    <div class="row"><label>Axis color</label><input id="axisColor" type="color" value="#ff7b7b"><div class="color-preview" id="axisPrev" style="background:#ff7b7b"></div></div>

    <h3>Points</h3>
    <div style="display:flex;gap:8px;margin-bottom:8px"><button id="addPoint" class="small">Add</button><button id="removePoint" class="small ghost">Remove</button><button id="normalize" class="small ghost">Normalize Arc</button></div>
    <div class="point-list" id="pointList"></div>

    <h3>Tools</h3>
    <div style="display:flex;gap:6px;flex-wrap:wrap"><button id="undoBtn" class="small ghost">Undo</button><button id="redoBtn" class="small ghost">Redo</button><button id="saveJSON" class="small ghost">Export JSON</button><button id="loadJSON" class="small ghost">Import JSON</button><input id="jsonFile" type="file" style="display:none"></div>

    <h3>SVG / Code</h3>
    <div class="row"><textarea id="svgCode" rows="4" placeholder="Paste SVG path..."></textarea></div>
    <div style="display:flex;gap:6px;margin-top:8px"><button id="loadSVG" class="small ghost">Load SVG</button><button id="copySVG" class="small ghost">Copy SVG</button></div>

    <div class="stats" id="leftStats">
      <div><b id="statsTitle">Arc stats</b></div>
      <div id="statWidth">Width: -</div>
      <div id="statHeight">Height: -</div>
      <div id="statVoxels">Voxels: -</div>
      <div id="statLen">Length (cells): -</div>
    </div>

    <div style="height:10px"></div>
    <div class="footer-small">Example image (uploaded): <a class="example-link" id="exampleImageLink">Open</a></div>
  </div>
</div>

<script>
/* ===========================
   Voxel Bezier Editor — v10
   Variant D:
   - Arc mode (3 control points)
   - Thickness supports decimals (e.g. 0.1 -> single-voxel generation)
   - Export: PNG + SVG (exact voxels polyline or optional smoothing)
   - Douglas–Peucker simplifier included
   =========================== */

/* ---------- Constants & locale ---------- */
const EXAMPLE_IMAGE_PATH = '/mnt/data/b9849a2e-ce2c-4f0c-ba80-0a07149624ec.png';

const LOCALES = {
  uk: {
    title: 'Редактор Воксельних Кривих v10',
    hotkeysTitle: 'Гарячі клавіші',
    hk: ['Shift+LMB — Add point','LMB — Drag point','RMB — Pan','Wheel — Zoom (Shift faster)'],
    statsTitle: 'Статистика арки',
    width: 'Ширина',
    height: 'Висота',
    voxels: 'Вокселів',
    length: 'Довжина'
  },
  en: {
    title: 'Voxel Bezier Editor v10',
    hotkeysTitle: 'Hotkeys',
    hk: ['Shift+LMB — Add point','LMB — Drag point','RMB — Pan','Wheel — Zoom (Shift faster)'],
    statsTitle: 'Arc stats',
    width: 'Width',
    height: 'Height',
    voxels: 'Voxels',
    length: 'Length'
  },
  ru: {
    title: 'Редактор Воксельных Кривых v10',
    hotkeysTitle: 'Горячие клавиши',
    hk: ['Shift+LMB — Add point','LMB — Drag point','RMB — Pan','Wheel — Zoom (Shift faster)'],
    statsTitle: 'Статистика арки',
    width: 'Ширина',
    height: 'Высота',
    voxels: 'Вокселей',
    length: 'Длина'
  }
};

/* ---------- DOM refs ---------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: true });
const hotkeysBox = document.getElementById('hotkeysBox');
const langSelect = document.getElementById('langSelect');
const uiTitle = document.getElementById('uiTitle');
const bgColorInput = document.getElementById('bgColor');
const bgPreview = document.getElementById('bgPreview');
const cellSizeInput = document.getElementById('cellSize');
const thickRange = document.getElementById('thickRange');
const thickVal = document.getElementById('thickVal');
const samplingQualitySel = document.getElementById('samplingQuality');
const fillGapsCb = document.getElementById('fillGaps');
const verticalStabCb = document.getElementById('verticalStabilize');
const mirrorModeSel = document.getElementById('mirrorMode');
const liveMirrorCb = document.getElementById('liveMirror');
const axisColorInput = document.getElementById('axisColor');
const axisPrev = document.getElementById('axisPrev');
const modeSelect = document.getElementById('modeSelect');
const addPointBtn = document.getElementById('addPoint');
const removePointBtn = document.getElementById('removePoint');
const normalizeBtn = document.getElementById('normalize');
const pointListEl = document.getElementById('pointList');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const exportPNGBtn = document.getElementById('exportPNG');
const exportSVGBtn = document.getElementById('exportSVG');
const copyArrayBtn = document.getElementById('copyArray');
const fitBtn = document.getElementById('fitBtn');
const svgCode = document.getElementById('svgCode');
const loadSVGBtn = document.getElementById('loadSVG');
const copySVGBtn = document.getElementById('copySVG');
const saveJSONBtn = document.getElementById('saveJSON');
const loadJSONBtn = document.getElementById('loadJSON');
const jsonFileInput = document.getElementById('jsonFile');
const statsTitle = document.getElementById('statsTitle');
const statWidth = document.getElementById('statWidth');
const statHeight = document.getElementById('statHeight');
const statVoxels = document.getElementById('statVoxels');
const statLen = document.getElementById('statLen');
const exampleImageLink = document.getElementById('exampleImageLink');

/* ---------- State ---------- */
let locale = localStorage.getItem('vbe_lang') || 'uk';
let state = {
  cellSize: parseInt(cellSizeInput.value) || 12,
  thickness: parseFloat(thickVal.value) || 1.0,
  samplingQuality: samplingQualitySel.value || 'medium',
  fillGaps: fillGapsCb.checked,
  verticalStabilize: verticalStabCb.checked,
  mirrorMode: mirrorModeSel.value || 'none',
  liveMirror: liveMirrorCb.checked,
  axisColor: axisColorInput.value || '#ff7b7b',
  bgColor: bgColorInput.value || '#071028',
  mode: modeSelect.value || 'voxels'
};

// camera in CSS pixels
let cam = { x: 0, y: 0, scale: 1 };
let canvasW = 1200, canvasH = 720;

// points in cell coordinates (editable nodes mode)
let points = [
  { x: 4, y: 18 },
  { x: 10, y: 6 },
  { x: 22, y: 6 },
  { x: 28, y: 18 }
];

let selectedIndex = -1;
let DPR = Math.max(1, window.devicePixelRatio || 1);

/* ---------- Undo/Redo ---------- */
let undoStack = [], redoStack = [];
function pushState() {
  undoStack.push(JSON.stringify({
    points: JSON.parse(JSON.stringify(points)),
    cam: { ...cam },
    state: { ...state },
    selectedIndex
  }));
  if (undoStack.length > 400) undoStack.shift();
  redoStack = [];
}
function doUndo() {
  if (!undoStack.length) return;
  redoStack.push(JSON.stringify({ points: JSON.parse(JSON.stringify(points)), cam: { ...cam }, state: { ...state }, selectedIndex }));
  const s = JSON.parse(undoStack.pop());
  points = s.points || points;
  cam = s.cam || cam;
  state = { ...state, ...(s.state || {}) };
  selectedIndex = -1;
  updateUIFromState();
  updatePointList();
  draw();
}
function doRedo() {
  if (!redoStack.length) return;
  undoStack.push(JSON.stringify({ points: JSON.parse(JSON.stringify(points)), cam: { ...cam }, state: { ...state }, selectedIndex }));
  const s = JSON.parse(redoStack.pop());
  points = s.points || points;
  cam = s.cam || cam;
  state = { ...state, ...(s.state || {}) };
  selectedIndex = -1;
  updateUIFromState();
  updatePointList();
  draw();
}

/* ---------- Math / Bezier / Voxelization ---------- */
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function deepCopy(o) { return JSON.parse(JSON.stringify(o)); }

/* de Casteljau for arbitrary-degree Bezier */
function bezierAt(pts, t) {
  let arr = pts.map(p => ({ x: p.x, y: p.y }));
  const n = arr.length;
  for (let r = 1; r < n; r++) {
    for (let i = 0; i < n - r; i++) {
      arr[i].x = (1 - t) * arr[i].x + t * arr[i + 1].x;
      arr[i].y = (1 - t) * arr[i].y + t * arr[i + 1].y;
    }
  }
  return arr[0];
}
function bezierTangent(pts, t, eps = 1e-4) {
  const t1 = Math.max(0, t - eps), t2 = Math.min(1, t + eps);
  const p1 = bezierAt(pts, t1), p2 = bezierAt(pts, t2);
  return { x: (p2.x - p1.x) / (t2 - t1 || eps), y: (p2.y - p1.y) / (t2 - t1 || eps) };
}
function estimateLength(pts, samples = 80) {
  if (!pts || pts.length < 2) return 0;
  let prev = bezierAt(pts, 0), L = 0;
  for (let i = 1; i <= samples; i++) {
    const p = bezierAt(pts, i / samples);
    const dx = p.x - prev.x, dy = p.y - prev.y;
    L += Math.hypot(dx, dy);
    prev = p;
  }
  return L;
}

function bresenham(x0, y0, x1, y1) {
  const cells = [];
  let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  let x = x0, y = y0;
  while (true) {
    cells.push([x, y]);
    if (x === x1 && y === y1) break;
    let e2 = 2 * err;
    if (e2 >= dy) { err += dy; x += sx; }
    if (e2 <= dx) { err += dx; y += sy; }
  }
  return cells;
}

function pointInPolygon(px, py, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i][0], yi = poly[i][1];
    const xj = poly[j][0], yj = poly[j][1];
    const intersect = ((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi + 0.0) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function rasterizeDisk(cxF, cyF, radiusCells, outSet) {
  const rI = Math.ceil(radiusCells + 0.7);
  for (let dx = -rI; dx <= rI; dx++) {
    for (let dy = -rI; dy <= rI; dy++) {
      const x = Math.round(cxF) + dx, y = Math.round(cyF) + dy;
      const dxC = x - cxF, dyC = y - cyF;
      if (Math.hypot(dxC, dyC) <= radiusCells + 0.7071) outSet.add(x + ',' + y);
    }
  }
}

function buildOffsetPolygon(pts, thicknessCells, samples) {
  const left = [], right = [];
  const r = thicknessCells / 2;
  for (let i = 0; i <= samples; i++) {
    const t = i / samples;
    const p = bezierAt(pts, t);
    const tg = bezierTangent(pts, t, Math.max(1e-4, 1 / samples));
    let nx = -tg.y, ny = tg.x;
    const nlen = Math.hypot(nx, ny) || 1e-6;
    nx /= nlen; ny /= nlen;
    left.push([p.x + nx * r, p.y + ny * r]);
    right.push([p.x - nx * r, p.y - ny * r]);
  }
  return left.concat(right.reverse());
}

function rasterizePolygon(poly) {
  if (!poly || poly.length < 3) return new Set();
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const [x, y] of poly) {
    minX = Math.min(minX, Math.floor(x));
    minY = Math.min(minY, Math.floor(y));
    maxX = Math.max(maxX, Math.ceil(x));
    maxY = Math.max(maxY, Math.ceil(y));
  }
  const cells = new Set();
  for (let cx = minX; cx <= maxX; cx++) {
    for (let cy = minY; cy <= maxY; cy++) {
      if (pointInPolygon(cx + 0.0, cy + 0.0, poly)) cells.add(cx + ',' + cy);
    }
  }
  return cells;
}

/* ---------- Generate voxel cells from current curve (or arc) ---------- */
function generateVoxelCells() {
  const out = new Set();
  if (!points || points.length < 2) return out;

  const len = estimateLength(points, 180);
  let samples = 0;
  if (state.samplingQuality === 'low') samples = Math.max(12, Math.round(len * 0.6));
  else if (state.samplingQuality === 'medium' || state.samplingQuality === 'auto') samples = Math.max(30, Math.round(len * 1.0));
  else if (state.samplingQuality === 'high') samples = Math.max(80, Math.round(len * 2.0));
  else samples = Math.max(30, Math.round(len * 1.2));
  samples = Math.min(4000, Math.max(24, samples));

  // if thickness <= 1 (including decimals like 0.1), use disk radius ~=0.49 and Bresenham linking
  if (state.thickness <= 1) {
    const radius = 0.49;
    let prevCenter = null;
    for (let i = 0; i <= samples; i++) {
      const t = i / samples;
      const p = bezierAt(points, t);
      rasterizeDisk(p.x, p.y, radius, out);
      const center = [Math.round(p.x), Math.round(p.y)];
      if (prevCenter) {
        const line = bresenham(prevCenter[0], prevCenter[1], center[0], center[1]);
        for (const [lx, ly] of line) rasterizeDisk(lx, ly, radius, out);
      }
      prevCenter = center;
    }
  } else {
    const poly = buildOffsetPolygon(points, state.thickness, samples);
    const polyCells = rasterizePolygon(poly);
    for (const c of polyCells) out.add(c);

    const radius = Math.max(0.5, state.thickness / 2);
    let prevCenter = null;
    for (let i = 0; i <= samples; i++) {
      const t = i / samples;
      const p = bezierAt(points, t);
      rasterizeDisk(p.x, p.y, radius, out);
      const center = [Math.round(p.x), Math.round(p.y)];
      if (prevCenter) {
        const line = bresenham(prevCenter[0], prevCenter[1], center[0], center[1]);
        for (const [lx, ly] of line) rasterizeDisk(lx, ly, radius, out);
      }
      prevCenter = center;
    }
  }

  if (state.verticalStabilize) {
    const cols = {};
    out.forEach(s => {
      const [x, y] = s.split(',').map(Number);
      if (!cols[x]) cols[x] = { min: y, max: y };
      else { cols[x].min = Math.min(cols[x].min, y); cols[x].max = Math.max(cols[x].max, y); }
    });
    for (const sx in cols) {
      const { min, max } = cols[sx];
      const x = parseInt(sx, 10);
      for (let y = min; y <= max; y++) out.add(x + ',' + y);
    }
  }

  if (state.mirrorMode !== 'none') {
    const adds = [];
    let axisX = 0, axisY = 0;
    if (state.mirrorMode === 'vertical') axisX = Math.round(((cam.x + (canvas.clientWidth / (cam.scale)) / 2) / state.cellSize));
    else if (state.mirrorMode === 'horizontal') axisY = Math.round(((cam.y + (canvas.clientHeight / (cam.scale)) / 2) / state.cellSize));
    else if (state.mirrorMode === 'point' && selectedIndex >= 0 && points[selectedIndex]) { axisX = Math.round(points[selectedIndex].x); axisY = Math.round(points[selectedIndex].y); }
    out.forEach(s => {
      const [x, y] = s.split(',').map(Number);
      if (state.mirrorMode === 'vertical') adds.push(Math.round(2 * axisX - x) + ',' + y);
      else if (state.mirrorMode === 'horizontal') adds.push(x + ',' + Math.round(2 * axisY - y));
      else if (state.mirrorMode === 'point') adds.push(Math.round(2 * axisX - x) + ',' + Math.round(2 * axisY - y));
    });
    adds.forEach(a => out.add(a));
  }

  return out;
}

/* ---------- Douglas–Peucker simplifier for optional SVG smoothing ---------- */
function douglasPeucker(pointsArr, epsilon) {
  if (pointsArr.length < 3) return pointsArr.slice();
  const sqr = (v) => v * v;
  function perpendicularDistanceSquared(pt, a, b) {
    const dx = b.x - a.x, dy = b.y - a.y;
    if (dx === 0 && dy === 0) return sqr(pt.x - a.x) + sqr(pt.y - a.y);
    const t = ((pt.x - a.x) * dx + (pt.y - a.y) * dy) / (dx * dx + dy * dy);
    const projx = a.x + t * dx, projy = a.y + t * dy;
    return sqr(pt.x - projx) + sqr(pt.y - projy);
  }
  function recurse(pts, first, last, epsSqr, outIdx) {
    let maxDist = -1, idx = -1;
    for (let i = first + 1; i < last; i++) {
      const d = perpendicularDistanceSquared(pts[i], pts[first], pts[last]);
      if (d > maxDist) { maxDist = d; idx = i; }
    }
    if (maxDist > epsSqr) {
      recurse(pts, first, idx, epsSqr, outIdx);
      recurse(pts, idx, last, epsSqr, outIdx);
    } else {
      outIdx.push(first);
    }
  }
  const outIdx = [];
  recurse(pointsArr, 0, pointsArr.length - 1, epsilon * epsilon, outIdx);
  outIdx.push(pointsArr.length - 1);
  outIdx.sort((a,b)=>a-b);
  return outIdx.map(i=>pointsArr[i]);
}

/* ---------- SVG generator (exact & optional smoothed) ---------- */
function computeSamplesForExport() {
  const len = estimateLength(points, 180);
  let samples = 0;
  if (state.samplingQuality === 'low') samples = Math.max(12, Math.round(len * 0.6));
  else if (state.samplingQuality === 'medium' || state.samplingQuality === 'auto') samples = Math.max(30, Math.round(len * 1.0));
  else if (state.samplingQuality === 'high') samples = Math.max(80, Math.round(len * 2.0));
  else samples = Math.max(30, Math.round(len * 1.2));
  samples = Math.min(4000, Math.max(24, samples));
  return samples;
}

function generateSVGCurve({ smooth=false, epsilon=0.5 } = {}) {
  if (!points || points.length < 2) return '';
  const steps = computeSamplesForExport();
  const sampled = [];
  for (let i = 0; i <= steps; i++) {
    const p = bezierAt(points, i / steps);
    sampled.push({ x: p.x * state.cellSize, y: p.y * state.cellSize });
  }

  let used = sampled;
  if (smooth && sampled.length>2) {
    // pick epsilon as pixels; default scaled by cellSize
    used = douglasPeucker(sampled, epsilon);
  }

  let d = '';
  for (let i = 0; i < used.length; i++) {
    const p = used[i];
    if (i===0) d += `M ${p.x.toFixed(3)} ${p.y.toFixed(3)}`;
    else d += ` L ${p.x.toFixed(3)} ${p.y.toFixed(3)}`;
  }

  const strokeWcells = Math.max(1, state.thickness);
  const strokeWpx = Math.max(1, (strokeWcells * state.cellSize));
  const W = canvas.clientWidth, H = canvas.clientHeight;
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}" shape-rendering="geometricPrecision">
  <rect width="100%" height="100%" fill="${state.bgColor}" />
  <path d="${d}" stroke="#06b6d4" fill="none" stroke-width="${strokeWpx.toFixed(2)}" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
  return svg;
}

/* ---------- SVG parsing (load) ---------- */
function parsePathToPoints(svgText) {
  const pathMatch = svgText.match(/<path[^>]*d=["']([^"']+)["']/i);
  let dStr = pathMatch ? pathMatch[1] : svgText;
  const nums = Array.from(dStr.matchAll(/-?\d+(\.\d+)?/g)).map(m => parseFloat(m[0]));
  if (nums.length < 4) return null;
  const newPts = [];
  for (let i = 0; i < nums.length - 1; i += 2) {
    if (newPts.length >= 1024) break;
    newPts.push({ x: Math.round(nums[i] / state.cellSize), y: Math.round(nums[i + 1] / state.cellSize) });
  }
  return newPts.length ? newPts : null;
}

/* ---------- Coordinate transforms & HiDPI ---------- */
function worldToScreen(p) {
  return { x: (p.x * state.cellSize - cam.x) * cam.scale, y: (p.y * state.cellSize - cam.y) * cam.scale };
}
function screenToWorld(px, py) {
  return { x: (px / cam.scale + cam.x) / state.cellSize, y: (py / cam.scale + cam.y) / state.cellSize };
}

/* ---------- Renderer ---------- */
function drawGrid() {
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = Math.max(1, 1 * DPR);
  const W = canvas.clientWidth, H = canvas.clientHeight;
  const startX = Math.floor((cam.x - 50) / state.cellSize) - 2;
  const endX = Math.floor((cam.x + (W / cam.scale) + 50) / state.cellSize) + 2;
  const startY = Math.floor((cam.y - 50) / state.cellSize) - 2;
  const endY = Math.floor((cam.y + (H / cam.scale) + 50) / state.cellSize) + 2;
  for (let cx = startX; cx <= endX; cx++) {
    const sx = (cx * state.cellSize - cam.x) * cam.scale;
    ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H); ctx.stroke();
  }
  for (let cy = startY; cy <= endY; cy++) {
    const sy = (cy * state.cellSize - cam.y) * cam.scale;
    ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(W, sy); ctx.stroke();
  }
  ctx.restore();
}

function drawSymAxis() {
  if (state.mirrorMode === 'none') return;
  ctx.save();
  ctx.strokeStyle = state.axisColor || '#ff7b7b';
  ctx.lineWidth = 2;
  const W = canvas.clientWidth, H = canvas.clientHeight;
  if (state.mirrorMode === 'vertical') {
    const axisX = ((cam.x + (W / (cam.scale)) / 2) / state.cellSize);
    const sx = (axisX * state.cellSize - cam.x) * cam.scale;
    ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H); ctx.stroke();
  } else if (state.mirrorMode === 'horizontal') {
    const axisY = ((cam.y + (H / (cam.scale)) / 2) / state.cellSize);
    const sy = (axisY * state.cellSize - cam.y) * cam.scale;
    ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(W, sy); ctx.stroke();
  } else if (state.mirrorMode === 'point' && selectedIndex >= 0) {
    const s = worldToScreen(points[selectedIndex]);
    ctx.beginPath(); ctx.arc(s.x, s.y, 8, 0, Math.PI * 2); ctx.stroke();
  }
  ctx.restore();
}

function drawControlPoints() {
  ctx.save();
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    const s = worldToScreen(p);
    ctx.beginPath();
    ctx.fillStyle = (i === selectedIndex) ? 'rgba(255,220,0,0.98)' : 'rgba(255,255,255,0.95)';
    ctx.arc(s.x, s.y, 6, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.font = '12px monospace'; ctx.fillText(i, s.x + 8, s.y + 4);
  }
  ctx.restore();
}

function drawCurvePreview() {
  ctx.save();
  const screenStroke = Math.max(1, DPR * Math.max(1, state.thickness * (state.cellSize / 4)));
  ctx.lineWidth = screenStroke;
  ctx.strokeStyle = 'rgba(6,182,212,0.95)';
  if (points.length > 0) {
    ctx.beginPath();
    const steps = Math.min(2000, Math.max(64, computeSamplesForExport()));
    let p0 = bezierAt(points, 0), s0 = worldToScreen(p0);
    ctx.moveTo(s0.x, s0.y);
    for (let i = 1; i <= steps; i++) {
      const p = bezierAt(points, i / steps); const s = worldToScreen(p); ctx.lineTo(s.x, s.y);
    }
    ctx.stroke();
  }
  ctx.restore();
}

function drawVoxels() {
  const cells = generateVoxelCells();
  updateStats(cells);
  ctx.save();
  ctx.lineWidth = 1;
  const W = canvas.clientWidth, H = canvas.clientHeight;
  for (const s of cells) {
    const [x, y] = s.split(',').map(Number);
    const screen = { x: (x * state.cellSize - cam.x) * cam.scale, y: (y * state.cellSize - cam.y) * cam.scale };
    if (screen.x + state.cellSize * cam.scale < -50 || screen.y + state.cellSize * cam.scale < -50 || screen.x > W + 50 || screen.y > H + 50) continue;
    let isMirror = false;
    if (state.mirrorMode === 'vertical') {
      const axisX = Math.round(((cam.x + (W / (cam.scale)) / 2) / state.cellSize));
      if (x > axisX) isMirror = true;
    } else if (state.mirrorMode === 'horizontal') {
      const axisY = Math.round(((cam.y + (H / (cam.scale)) / 2) / state.cellSize));
      if (y > axisY) isMirror = true;
    } else if (state.mirrorMode === 'point' && selectedIndex >= 0) {
      const ax = Math.round(points[selectedIndex].x); if (x > ax) isMirror = true;
    }
    ctx.fillStyle = isMirror ? 'rgba(255,123,123,0.95)' : 'rgba(6,182,212,0.95)';
    const size = Math.max(1, Math.round(state.cellSize * cam.scale));
    ctx.fillRect(Math.round(screen.x) + 0.5, Math.round(screen.y) + 0.5, size, size);
  }
  ctx.restore();
}

function draw() {
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.max(1, Math.round(canvas.clientWidth * DPR));
  canvas.height = Math.max(1, Math.round(canvas.clientHeight * DPR));
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  ctx.fillStyle = state.bgColor || '#071028';
  ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

  drawGrid();
  drawSymAxis();
  if (state.mode === 'curve' || state.mode === 'arc') drawCurvePreview(); else drawVoxels();
  drawControlPoints();
  renderHotkeys();
}

/* ---------- Input / Pointer / Pan / Zoom ---------- */
let activePointer = null, isPanning = false, panStart = null, isDraggingPoint = false;
canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  activePointer = e.pointerId;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left);
  const my = (e.clientY - rect.top);
  if (e.button === 2) { isPanning = true; panStart = { mx: e.clientX, my: e.clientY, camX: cam.x, camY: cam.y }; return; }
  // Shift+LMB = add / replace (arc mode special)
  if (e.shiftKey && e.button === 0) {
    pushState();
    const w = screenToWorld(mx, my);
    if (state.mode === 'arc') {
      // Arc mode: keep at most 3 control points
      if (points.length < 3) points.push({ x: Math.round(w.x), y: Math.round(w.y) });
      else {
        // replace nearest point to clicked spot
        let nearest = 0, nd = Infinity;
        for (let i=0;i<3;i++){
          const dx = points[i].x - w.x, dy = points[i].y - w.y, d = dx*dx+dy*dy;
          if (d < nd) { nd = d; nearest = i; }
        }
        points[nearest] = { x: Math.round(w.x), y: Math.round(w.y) };
      }
      // ensure array length <=3
      if (points.length > 3) points = points.slice(0,3);
    } else {
      // normal add
      points.push({ x: Math.round(w.x), y: Math.round(w.y) });
    }
    selectedIndex = points.length - 1;
    updatePointList(); draw(); return;
  }
  const tol = 10;
  let found = false;
  for (let i = 0; i < points.length; i++) {
    const s = worldToScreen(points[i]);
    if (Math.hypot(s.x - mx, s.y - my) <= tol) { found = true; selectedIndex = i; isDraggingPoint = true; updatePointList(); break; }
  }
  if (!found) { selectedIndex = -1; updatePointList(); draw(); } else draw();
});
window.addEventListener('pointermove', (e) => {
  if (activePointer !== null && e.pointerId !== activePointer) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left);
  const my = (e.clientY - rect.top);
  if (isPanning && panStart) {
    const dx = (e.clientX - panStart.mx) / cam.scale;
    const dy = (e.clientY - panStart.my) / cam.scale;
    cam.x = panStart.camX - dx;
    cam.y = panStart.camY - dy;
    draw(); return;
  }
  if (isDraggingPoint && selectedIndex >= 0) {
    const w = screenToWorld(mx, my);
    points[selectedIndex].x = Math.round(w.x);
    points[selectedIndex].y = Math.round(w.y);
    draw();
  }
});
window.addEventListener('pointerup', (e) => {
  if (activePointer !== null && e.pointerId !== activePointer) return;
  try { canvas.releasePointerCapture(e.pointerId); } catch (err) { }
  activePointer = null;
  if (isDraggingPoint) { isDraggingPoint = false; pushState(); }
  if (isPanning) { isPanning = false; panStart = null; pushState(); }
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left);
  const my = (e.clientY - rect.top);
  const worldBefore = screenToWorld(mx, my);
  const zoomFactor = (e.shiftKey ? 1.15 : 1.05);
  cam.scale = e.deltaY > 0 ? cam.scale / zoomFactor : cam.scale * zoomFactor;
  cam.scale = Math.max(0.12, Math.min(8, cam.scale));
  const worldAfter = screenToWorld(mx, my);
  cam.x += (worldBefore.x - worldAfter.x) * state.cellSize;
  cam.y += (worldBefore.y - worldAfter.y) * state.cellSize;
  draw();
}, { passive: false });

/* ---------- Keyboard ---------- */
window.addEventListener('keydown', (e) => {
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
  const isInput = tag === 'input' || tag === 'textarea' || e.target.isContentEditable;
  if (e.key === 'Delete' && selectedIndex >= 0 && !isInput) {
    e.preventDefault();
    pushState();
    points.splice(selectedIndex, 1);
    selectedIndex = -1;
    updatePointList();
    draw();
    return;
  }
  if ((e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') && selectedIndex >= 0) {
    e.preventDefault();
    pushState();
    const step = (e.shiftKey ? 5 : 1);
    if (e.key === 'ArrowUp') points[selectedIndex].y -= step;
    if (e.key === 'ArrowDown') points[selectedIndex].y += step;
    if (e.key === 'ArrowLeft') points[selectedIndex].x -= step;
    if (e.key === 'ArrowRight') points[selectedIndex].x += step;
    updatePointList(); draw();
  }
});

/* ---------- UI bindings ---------- */
function updateUIFromState() {
  cellSizeInput.value = state.cellSize;
  thickRange.value = state.thickness; thickVal.value = state.thickness;
  samplingQualitySel.value = state.samplingQuality;
  fillGapsCb.checked = state.fillGaps;
  verticalStabCb.checked = state.verticalStabilize;
  mirrorModeSel.value = state.mirrorMode;
  liveMirrorCb.checked = state.liveMirror;
  axisColorInput.value = state.axisColor; axisPrev.style.background = state.axisColor;
  bgColorInput.value = state.bgColor; bgPreview.style.background = state.bgColor;
  modeSelect.value = state.mode;
  langSelect.value = locale;
  uiTitle.textContent = LOCALES[locale].title;
  statsTitle.textContent = LOCALES[locale].statsTitle;
  renderHotkeys();
}
langSelect.addEventListener('change', () => { locale = langSelect.value; localStorage.setItem('vbe_lang', locale); updateUIFromState(); draw(); });
bgColorInput.addEventListener('input', (e) => { state.bgColor = e.target.value; bgPreview.style.background = state.bgColor; localStorage.setItem('vbe_bg', state.bgColor); draw(); });
cellSizeInput.addEventListener('change', (e) => { state.cellSize = Math.max(1, +e.target.value); pushState(); draw(); });
thickRange.addEventListener('input', (e) => { thickVal.value = e.target.value; state.thickness = Math.max(0.1, parseFloat(e.target.value)); pushState(); draw(); });
thickVal.addEventListener('change', (e) => { state.thickness = Math.max(0.1, parseFloat(e.target.value)); thickRange.value = Math.min(40, state.thickness); pushState(); draw(); });
samplingQualitySel.addEventListener('change', (e) => { state.samplingQuality = e.target.value; draw(); });
fillGapsCb.addEventListener('change', (e) => { state.fillGaps = e.target.checked; pushState(); draw(); });
verticalStabCb.addEventListener('change', (e) => { state.verticalStabilize = e.target.checked; pushState(); draw(); });
mirrorModeSel.addEventListener('change', (e) => { state.mirrorMode = e.target.value; pushState(); draw(); });
liveMirrorCb.addEventListener('change', (e) => { state.liveMirror = e.target.checked; });
axisColorInput.addEventListener('input', (e) => { state.axisColor = e.target.value; axisPrev.style.background = state.axisColor; localStorage.setItem('vbe_axis', state.axisColor); draw(); });

modeSelect.addEventListener('change', (e) => {
  state.mode = e.target.value;
  // If entering arc mode, constrain points to max 3
  if (state.mode === 'arc') {
    if (points.length > 3) points = points.slice(0,3);
    // if fewer than 3, keep as-is (user can add)
  }
  pushState();
  draw();
});

addPointBtn.addEventListener('click', () => {
  pushState();
  const midX = Math.round((canvas.clientWidth / 2 + cam.x) / state.cellSize);
  const midY = Math.round((canvas.clientHeight / 2 + cam.y) / state.cellSize);
  if (state.mode === 'arc') {
    if (points.length < 3) points.push({ x: midX, y: midY });
    else {
      // replace last if already 3
      points[points.length-1] = { x: midX, y: midY };
    }
  } else {
    points.push({ x: midX, y: midY });
  }
  selectedIndex = points.length - 1; updatePointList(); draw();
});
removePointBtn.addEventListener('click', () => { if (selectedIndex >= 0) { pushState(); points.splice(selectedIndex, 1); selectedIndex = -1; updatePointList(); draw(); }});
normalizeBtn.addEventListener('click', () => { pushState(); const newPts = points.map(p => ({ x: p.x, y: p.y })); for (let i = 1; i < points.length - 1; i++) newPts[i].y = Math.round((points[i - 1].y + points[i].y + points[i + 1].y) / 3); points = newPts; updatePointList(); draw(); });

undoBtn.addEventListener('click', () => doUndo()); redoBtn.addEventListener('click', () => doRedo());

exportPNGBtn.addEventListener('click', () => {
  const W = canvas.clientWidth, H = canvas.clientHeight;
  const tmp = document.createElement('canvas');
  tmp.width = Math.round(W * DPR);
  tmp.height = Math.round(H * DPR);
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = state.bgColor; tctx.fillRect(0, 0, tmp.width, tmp.height);
  tctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  const cells = generateVoxelCells();
  tctx.fillStyle = '#06b6d4';
  for (const s of cells) {
    const [x, y] = s.split(',').map(Number);
    const sx = (x * state.cellSize - cam.x) * cam.scale;
    const sy = (y * state.cellSize - cam.y) * cam.scale;
    const size = Math.max(1, Math.round(state.cellSize * cam.scale));
    tctx.fillRect(Math.round(sx), Math.round(sy), size, size);
  }
  const a = document.createElement('a'); a.href = tmp.toDataURL('image/png'); a.download = 'voxel_curve.png'; a.click();
});

exportSVGBtn.addEventListener('click', async () => {
  const svgExact = generateSVGCurve({ smooth:false });
  if (!svgExact) return alert('Not enough points');
  // ask user whether to produce smoothed simplified SVG
  const doSmooth = confirm('Експорт SVG: натисни OK для згладженого (спрощеного) SVG, Cancel — щоб експортувати точну воксельну форму.');
  let svgToCopy = svgExact;
  if (doSmooth) {
    // choose epsilon based on cellSize: smaller cells -> smaller epsilon
    const eps = Math.max(0.5, state.cellSize * 0.6);
    svgToCopy = generateSVGCurve({ smooth:true, epsilon: eps });
  }
  svgCode.value = svgToCopy;
  try {
    await navigator.clipboard.writeText(svgToCopy);
    alert('SVG згенеровано і скопійовано у буфер обміну.');
  } catch (err) {
    alert('SVG згенеровано (див. поле нижче). Не вдалось скопіювати: ' + (err && err.message));
  }
});

copyArrayBtn.addEventListener('click', async () => {
  const cells = generateVoxelCells();
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  cells.forEach(s => { const [x, y] = s.split(',').map(Number); minX = Math.min(minX, x); minY = Math.min(minY, y); maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); });
  if (minX === Infinity) return alert('No voxels');
  const w = maxX - minX + 1, h = maxY - minY + 1;
  const arr = Array.from({ length: h }, () => Array.from({ length: w }, () => 0));
  cells.forEach(s => { const [x, y] = s.split(',').map(Number); arr[y - minY][x - minX] = 1; });
  const text = JSON.stringify({ w, h, minX, minY, array: arr });
  await navigator.clipboard.writeText(text);
  alert('2D array copied (JSON)');
});

fitBtn.addEventListener('click', () => {
  if (!points.length) return;
  const samples = 200;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (let i = 0; i <= samples; i++) {
    const p = bezierAt(points, i / samples);
    minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
  }
  const w = (maxX - minX + 4) * state.cellSize;
  const h = (maxY - minY + 4) * state.cellSize;
  const sx = canvas.clientWidth / w; const sy = canvas.clientHeight / h;
  cam.scale = Math.min(sx, sy) * 0.9;
  cam.x = minX * state.cellSize - (canvas.clientWidth / cam.scale - (maxX - minX + 4) * state.cellSize) / 2 / cam.scale;
  cam.y = minY * state.cellSize - (canvas.clientHeight / cam.scale - (maxY - minY + 4) * state.cellSize) / 2 / cam.scale;
  draw();
});

// JSON import/export
saveJSONBtn.addEventListener('click', () => {
  const data = { points, state, cam };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'vbe_project.json'; a.click();
});
loadJSONBtn.addEventListener('click', () => jsonFileInput.click());
jsonFileInput.addEventListener('change', (e) => {
  const f = e.target.files[0]; if (!f) return;
  const r = new FileReader();
  r.onload = () => {
    try {
      const data = JSON.parse(r.result);
      pushState();
      points = data.points || points;
      state = { ...state, ...(data.state || {}) };
      cam = data.cam || cam;
      updateUIFromState(); updatePointList(); draw();
    } catch (err) { alert('JSON read error'); }
  };
  r.readAsText(f);
});

// SVG load/copy (improved)
loadSVGBtn.addEventListener('click', () => {
  const svgText = svgCode.value;
  if (!svgText) return alert('SVG code empty');
  const newPts = parsePathToPoints(svgText);
  if (!newPts || newPts.length < 2) return alert('Cannot parse SVG');
  pushState(); points = newPts;
  // If arc mode, trim to 3
  if (state.mode === 'arc' && points.length > 3) points = points.slice(0,3);
  updatePointList(); draw();
});
copySVGBtn.addEventListener('click', async () => {
  const svg = generateSVGCurve();
  if (!svg) return alert('Not enough points');
  svgCode.value = svg;
  try {
    await navigator.clipboard.writeText(svg);
    alert('SVG copied to clipboard');
  } catch (err) {
    alert('Clipboard write failed: ' + (err && err.message));
  }
});

/* Top-center action buttons */
document.addEventListener('DOMContentLoaded', () => {
  const undoTop = document.getElementById('undoTop');
  const redoTop = document.getElementById('redoTop');
  const copySVGTop = document.getElementById('copySVGTop');
  const pasteSVGTop = document.getElementById('pasteSVGTop');
  const deleteTop = document.getElementById('deleteTop');

  if (undoTop) undoTop.addEventListener('click', () => doUndo());
  if (redoTop) redoTop.addEventListener('click', () => doRedo());
  if (copySVGTop) copySVGTop.addEventListener('click', async () => {
    const svg = generateSVGCurve();
    if (!svg) return alert('Not enough points');
    try {
      await navigator.clipboard.writeText(svg);
      alert('SVG copied to clipboard');
    } catch (err) {
      alert('Clipboard write failed: ' + (err && err.message));
    }
  });
  if (pasteSVGTop) pasteSVGTop.addEventListener('click', async () => {
    try {
      const txt = await navigator.clipboard.readText();
      if (!txt) return alert('Clipboard is empty');
      svgCode.value = txt;
      alert('Pasted into SVG field. Press "Load SVG" to import points.');
    } catch (err) {
      alert('Clipboard read failed: ' + (err && err.message));
    }
  });
  if (deleteTop) deleteTop.addEventListener('click', () => {
    if (selectedIndex >= 0) {
      pushState();
      points.splice(selectedIndex, 1);
      selectedIndex = -1;
      updatePointList();
      draw();
    } else {
      alert('No point selected');
    }
  });
});

/* ---------- Point list UI ---------- */
function updatePointList() {
  pointListEl.innerHTML = '';
  points.forEach((p, i) => {
    const div = document.createElement('div'); div.className = 'point-item';
    div.innerHTML = `<div>#${i} — (${Math.round(p.x)},${Math.round(p.y)})</div>
      <div style="display:flex;gap:6px">
        <button class="small ghost sel" data-i="${i}">Select</button>
        <button class="small ghost del" data-i="${i}">X</button>
      </div>`;
    pointListEl.appendChild(div);
  });
  pointListEl.querySelectorAll('.sel').forEach(b => b.addEventListener('click', () => { selectedIndex = +b.dataset.i; updatePointList(); draw(); }));
  pointListEl.querySelectorAll('.del').forEach(b => b.addEventListener('click', () => { pushState(); points.splice(+b.dataset.i, 1); selectedIndex = -1; updatePointList(); draw(); }));
}

/* ---------- Hotkeys rendering ---------- */
function renderHotkeys() {
  const L = LOCALES[locale];
  hotkeysBox.innerHTML = `<b>${L.hotkeysTitle}</b><br>${L.hk.join('<br>')}`;
}

/* ---------- Stats update ---------- */
function updateStats(cells) {
  if (!cells) cells = new Set();
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  cells.forEach(s => {
    const [x, y] = s.split(',').map(Number);
    minX = Math.min(minX, x); minY = Math.min(minY, y);
    maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
  });
  if (minX === Infinity) {
    statWidth.textContent = `${LOCALES[locale].width}: -`;
    statHeight.textContent = `${LOCALES[locale].height}: -`;
    statVoxels.textContent = `${LOCALES[locale].voxels}: 0`;
    statLen.textContent = `${LOCALES[locale].length}: -`;
    return;
  }
  const w = maxX - minX + 1, h = maxY - minY + 1;
  statWidth.textContent = `${LOCALES[locale].width}: ${w}`;
  statHeight.textContent = `${LOCALES[locale].height}: ${h}`;
  statVoxels.textContent = `${LOCALES[locale].voxels}: ${cells.size}`;
  const len = Math.round(estimateLength(points, 200));
  statLen.textContent = `${LOCALES[locale].length}: ${len}`;
}

/* ---------- Canvas init / resize ---------- */
function drawAll() {
  canvasW = canvas.clientWidth; canvasH = canvas.clientHeight;
  draw();
}
window.addEventListener('resize', () => {
  clearTimeout(window._vbe_resize);
  window._vbe_resize = setTimeout(drawAll, 60);
});

/* ---------- Init ---------- */
function init() {
  try {
    const s = JSON.parse(localStorage.getItem('vbe_settings') || '{}');
    state = { ...state, ...s };
    const p = JSON.parse(localStorage.getItem('vbe_points') || 'null');
    if (p && Array.isArray(p)) points = p;
  } catch (err) { /* ignore */ }

  updateUIFromState(); updatePointList(); renderHotkeys();

  exampleImageLink.addEventListener('click', () => {
    window.open(EXAMPLE_IMAGE_PATH, '_blank');
  });

  drawAll();
  pushState();
}

init();

/* expose for debugging */
window.VoxelEditorV10 = { points, state, cam, generateVoxelCells, draw };
</script>
</body>
</html>
